 == Testcases for AlphaCiv ==
 the game does not continue in year 2900 bc
 units should not be able to move after end of game
 Unit cost is deducted from city production treasury


== Testcases for Betaciv ==
Blue player has then city at (1,1) – Blue player is the winner
Initially no player should have won
Test: intiallyNoPlayerShouldHaveWon
Its age 4000BC I - Next turn it is age 3900BC
Test: ageShouldAdvanceTimeBy100AtEndOfFirstRound
Its age 100BC - Next turn it is age 1BC
Test: ageShouldAdvanceFrom100BCTo1BC
Its age 1BC - Next turn it is age 1AD
Test: ageShouldAdvanceFrom1BCTo1AD
Its age 1AD - - Next turn it is age 50AD
Test: ageShouldAdvanceFrom1ADTo50AD
Its age 1700AD - - Next turn it is age 1750AD
Test: ageShouldAdvanceFrom1700ADTo1750AD
Its age 1875AD - - Next turn it is age 1900AD
Test: ageShouldAdvanceFrom1875ADTo1900AD
Its age 1900AD – Next turn it is age 1905 AD
Test: ageShouldAdvanceFrom1900ADTo1905AD
Its age 1970AD - - Next turn it is age 1971AD
Test: ageShouldAdvanceFrom1YearFrom1970AD
Age initially be 4000BC
Test: StartAgeShuldBe4000BC

== Testcases for gammaciv ==
There is a city and no settler at (4,3) after build action
archers should have defence of 3 after 2 actions
archers should have defence of 6 after action
archers should have defence of 3 before actions
archers should not be able to move after action
fortified archers movement should not be restored
red settler should not be able to perform action on blue players turn

== Testcases for deltaciv ==
There should be 12 forests on the map
There should be 10 hills on the map
There should be 9 mountains on the map
There should be 86 oceans on the map
There should be 139 plains on the map
There should be a Red City at (8,12)
There should be a Red City at (4,5)
can Read Map File
RandomTileTest

***********************************************
=============== Test til DeltaCiv ==============
***************************************************

@Test// kommer ikke til at virke først grundet plain.class etc.
	public void testRandomTilesOnTheDeltaMap() {

		assertEquals("Should be plains at (5,5)", Plain.class, //<-- doh!
				game.getTileAt(new Position(5, 5)).getTypeString());
		assertEquals("Should be hills at (4,9)", Hill.class,
				game.getTileAt(new Position(4, 9)).getTypeString());
		assertEquals("Should be mountains at (0,5)", Mountain.class,
				game.getTileAt(new Position(0, 5)).getTypeString());
		assertEquals("Should be oceans at (8,6)", Ocean.class,
				game.getTileAt(new Position(8, 6)).getTypeString());
		assertEquals("Should be forest at (10,1)", Forest.class,
				game.getTileAt(new Position(9, 1)).getTypeString());
		assertEquals("Should be oceans at (13,13)", Ocean.class,
				game.getTileAt(new Position(13, 13)).getTypeString());
		assertEquals("Should be hills at (14,5)", Hill.class,
				game.getTileAt(new Position(14, 6)).getTypeString());
		assertEquals("Should be plains at (7,2)", Plain.class,
				game.getTileAt(new Position(7, 2)).getTypeString());
	}

@Test
	public void canReadMapFile() {
		DeltaCivMap dcm = new DeltaCivMap();
		Tile[][] tMap = dcm.getWorld();
		assertNotNull("Returns a map", tMap);
	}

@Test
	public void thereShouldBe12ForestsOnTheMap() {
		int n = 0;
		for (int r = 0; r < GameConstants.WORLDSIZE; r++) {
			for (int c = 0; c < GameConstants.WORLDSIZE; c++) {
				String l = game.getTileAt(new Position(r, c)).getTypeString();
				if (l.equals(Forest.class, l.getClass())) {
					n++;
				}
			}
		}
		assertEquals("There should be 12 forests on the map", 12, n);

@Test
	public void thereShouldBe9MountainsOnTheMap() {
		int n = 0;
		for (int r = 0; r < GameConstants.WORLDSIZE; r++) {
			for (int c = 0; c < GameConstants.WORLDSIZE; c++) {
				String l = game.getTileAt(new Position(r, c)).getTypeString();
				if (l.equals(Mountain.class, l.getClass()) {
					n++;
				}
			}
		}
		assertEquals("There should be 9 mountain tiles on the map", 9, n);

@Test
	public void thereShouldBe139PlainsOnTheMap() {
		int n = 0;
		for (int r = 0; r < GameConstants.WORLDSIZE; r++) {
			for (int c = 0; c < GameConstants.WORLDSIZE; c++) {
				String l = game.getTileAt(new Position(r, c)).getTypeString();
				if (l.equals(Plain.class, l.getClass()) {
					n++;
				}
			}
		}
		assertEquals("There should be 139 plain tiles on the map", 139, n);
	}

@Test
	public void thereShouldBe86OceansOnTheMap() {
		int n = 0;
		for (int r = 0; r < GameConstants.WORLDSIZE; r++) {
			for (int c = 0; c < GameConstants.WORLDSIZE; c++) {
				String l = game.getTileAt(new Position(r, c)).getTypeString();
				if (l.equals(Ocean.class,l.getClass()) {
					n++;
				}
			}
		}
		assertEquals("There should be 86 ocean tiles on the map", 86, n);
	}

@Test
	public void thereShouldBe10HillsOnTheMap() {
		int n = 0;
		for (int r = 0; r < GameConstants.WORLDSIZE; r++) {
			for (int c = 0; c < GameConstants.WORLDSIZE; c++) {
				String l = game.getTileAt(new Position(r, c)).getTypeString();
				if (l.equals(Hill.class,l.getClass()) {
					n++;
				}
			}
		}
		assertEquals("There should be 10 hill tiles on the map", 10, n);
	}

@Test
	public void shouldHaveBlueCityAt4_5() {
		City c = game.getCityAt(new Position(4,5));
		assertNotNull("There should be a city at (4,5)", c);
		Player p = c.getOwner(); // should be blue
		assertEquals( "City at (4,5) should be owned by blue",
				Player.BLUE, p );
	}

@Test
	public void shouldHaveRedCityAt8_12() {
		City c = game.getCityAt(new Position(8,12));
		assertNotNull("There should be a city at (8,12)", c);
		Player p = c.getOwner(); // should be red
		assertEquals( "City at (8,12) should be owned by blue",
				Player.RED, p );
	}

==================================================















Rapport:

Vi startede med at få noget af funktionaliteten ud af GameImpl-klassen og ind i 4 nye interfaces som blev skabt
til anledningen. Disse var CivMapStrategy, CivUnitStrategy, CivWinStrategy og CivAgeStrategy.
Disse har så konkrete klasser f.eks har CivAgeStrategy: AlphaCivAge og BetaCivAge der styrer hvordan tiden
forløber i de 2 pågældende former af hotciv som er AlphaCiv og BetaCiv.
Dette var før styret af GameImpl. Det vil sige at vi har refaktoriseret ansvaret for ageing ud af GameImpl og
ind i et strategypattern for at kunne styrer flere former af hotciv samtidig.
Det samme er gjort ved map varianterne. Dette er gjort fordi de forskellige algoritmer bruges til samme
arbejde. Specifikt ved DeltaCiv lød opgaven på at man kunne skrive algoritmer for at generer maps  og derfor
har vi lavet en algoritmen der kan læse en txt-fil og generer et map udfra det.
Udfra definition af variability points fandt vi følgende points:
1. Unit actions
2. Map
3. Winning
4. Age

I unit actions fulgte vi 3-1-2 således at vi identificerede udfra specifikationerne fra de forskellige
opgaver at unitactions er unikt fra form til form. Efter vi har fundet vores varians skulle vi nu
ifølge Punkt 1 og 2 i 3-1-2 programmerer et interface som blev til CivUnitStrategy-interfacet.
Grunden til at at vi ikke valgte inheritance er at da vi skal genbruge unit actions implementationerne
i de forskellige forme og dette kan være svært ved inheritance. Udover genbrug af formene bindes den
konkrete form ved compile-time hvilket ikke gør det muligt at give den pågældende unit nye
actions i run-time, dog endnu ikke er et problem. Den største fordel ved at bruge strategypattern er
at man uddelegere ansvar til flere klasser.

